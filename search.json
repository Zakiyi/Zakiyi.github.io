[{"title":"Pro Git笔记２","url":"/2019/04/22/Pro-Git-2/","content":"\n### Git 常用命令\n#### 初始化与配置\n```\ngit init　　　　　　　　　# 初始化仓库\ngit config --list      # 检查配置信息\ngit config --global user.name        # 设置用户名\ngit config --global user.email       # 设置用户邮箱\ngit config --global core.editor      # 设置文本编辑器\ngit config --global alias.xx xxxx    # 设置命令别名\n```\n\n#### 文件基本操作\n```\ngit add       # 对当前追踪的文件制作快照，并将其索引添加至暂存区, 用于下一次提交（快照备份　＋　建立索引）\ngit status    # 查看文件状态，是否追踪，修改，(待)提交等\ngit diff　　　 # 比较工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容\n\ngit commit　　 # 生成提交信息（git status 里的内容），并将暂存区快照（索引）提交至仓库\n　　　　　　　　　　-a: 跳过 git add 步骤，直接将追踪的文件以及相应的提交信息，提交至仓库\n                 --amend: 执行后本次提交会覆盖上次提交(git log 可以发现前后两次提交记录只算一次)\n\ngit rm　　　　　# 删除已追踪文件\n　　　　　　　　　　-f: 强制删除已加入暂存区的文件\n　　　　　　　　　　-cached: 取消文件已追踪状态，但会保留其本地存储内容\n\ngit mv        # 移动文件或者重命名文件\ngit log       # 查看提交历史\n                --pretty=oneline  master: 查看某一分支提交历史\ngit reset     # 取消文件暂存,　但并不会修改工作目录的文件.　可以理解为取消对 tracked 文件更新做快照备份\ngit checkout　--  # 撤销修改，恢复文件至上一次提交时的状态, (所以这命令比较危险，因为会直接修改覆盖本地工作目录的文件)\ngit clean     # 清理工作目录\n　　　　　　　　　　-f: 强制移除文件\n　　　　　　　　　　-d: 必须跟-f 一起，表示文件夹也一起移除\n　　　　　　　　　　-n: 显示哪些文件将被删除\n　　　　　　　　　　-x: 表示将　.gitignore 里忽略的文件一起删除\n```\n>注意 git rm 只能对已追踪的 (tracked) 文件进行操作，对于已追踪但是未加入暂存区 (index) 的文件 (unstaged)，直接 git rm file_name;   \n对已加入 index 的文件则需要加入 -f 进行强制删除，git rm -r file_name；   \n这两个命令会将整个文件从本地磁盘删掉，如果只是希望不再追踪此文件，但是仍希望保存其在本地目录，那么需要执行 git rm -cached file_name　或是　git rm filefolder/\\\\\\*.suffix;  \n>  \n如果文件已经被添加至 index，同时在外部删除该文件，那么 git status 会显示 unstaged commit．  \n此时执行 git add.，或者 git rm 会有一点类似，都会在下一次 commit 时提交信息中会包含这一改动，如　\"deleted xx_file\"；　如果\n>>虽然通过 .gitignore 添加文件也可以取消某类文件的追踪，但是要取消已追踪文件还是要通过 git rm.　\n\n#### 仓库基本操作\n```\ngit branch　　　　　# 得到当前所有分支的一个列表, * 字符标记的分支表示当前所在分支\n　　　　　　　　　　　　-v: 查看每一个分支的最后一次提交\n                    -d: 删除分支\n                    -r: 查看远程分支\n                    -a: 查看所有分支，包括本地分支，以及远程分支\n                    -u: 设置本地分支\n              --merged: 查看哪些分支已经合并到当前分支\n           --no-merged: 查看尚未合并到当前分支的分支\n\ngit merge　　　　　 # 合并分支至 master\ngit checkout　　   # 切换分支\n                    -b:　切换并新建分支    \n```\n#### 远程仓库操作\n```\ngit remote   # 显示远程仓库的简写\n　　　　　　　　　-v: 显示远程仓库使用的 Git 保存的简写与其对应的 URL\n             -add: <shortname> <url> 添加一个新的远程 Git 仓库, 并指定其简写名称\n           rename: 远程仓库重命名\n           　　 rm: 移除远程仓库\n　　　　　　　　show: [remote-name] 显示远程仓库信息\n\ngit clone    #　获取远程仓库所有数据至本地, git clone url filefolder 可以指定本地仓库文件夹名　　　　　\ngit fetch    # 从远程仓库获取更新，并将本地远程引用指向最新一次提交对象\ngit pull　　　# 获取远程仓库某一分支数据，并\ngit push     # 推送本地分支至远程仓库分支\n               git push origin branch     #　推送本地 branch 至远程相同 branch\n　　　　　　　　　git push origin local_branch:remote_branch   #　推送指定本地 branch 至远程指定 branch\n\n```\n> 如果远程仓库发生变化，比如其他用户进行了更新，那么此时推送会被拒绝．必须先将远程仓库 git pull.  \ngit clone 会给远程仓库自动添加 origin 的简称, 且自动设置本地 master 分支跟踪 colned 远程仓库的 master 分支（或其他默认分支）\n\n#### 底层命令\n```\ngit hash-object -w file_name   # 将文件保存为 blob 对象，返回校验和（SHA-1哈希值）\ngit write-tree　　　　　　　　　  # 创建树对象\ngit update-index --add --cacheinfo  # 更新索引文件, 后面应给出文件模式，文件校验和，文件名\ngit cat-file -t 'hash-value'   # 查看 Git 存储文件类型，输出为: tree, blob, 或者 commit\ngit cat-file -p 'hash-value'   # 根据给定的哈希值, 查看对应 .git/objects 下的存储文件信息\n```\n```\n\n>至此，可以看出每次暂存操作会计算每个文件校验和，将每个文件保存成 blob　对象，并以生成的校验和作为目录名和文件名\n","tags":["Git"]},{"title":"Pro Git笔记１","url":"/2019/04/22/Pro-Git-1/","content":"\n### １．Git 简介\n\nGit是一种开源分布式版本控制系统(VCS)，也是 Github 的核心。Git 具有简单，快速，高效，可扩展性好等优点，所以 Git 也是目前最受欢迎的 VCS。([Git 简史](https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-Git-%E7%AE%80%E5%8F%B2))\n\nGit 提供了多种使用模式，桌面客户端或者是命令行模式，以方便用户进行项目版本管理，以及不同用户之间的协同项目处理。\n\n命令行模式下，用户可以使用所有的命令操作实现 Git 全部功能，相较之下，GUI 模式只是 Git 简化版。\n\nGit 本质上是一个内容寻址文件系统 (所以 Git 的核心部分是一个简单的键值对数据库)。通过对文件制作快照并保存其索引，以实现记录和追踪文件数据的修改变更，甚至包括数据撤销恢复等操作。\n>[Git 中的快照](https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-Git-%E5%9F%BA%E7%A1%80)，相当于一种备份，但是 Git 会对改写后的文件数据进行特殊压缩，打包，存储等处理以提升效率，节省空间。同时 Git 会根据文件内容生成校验和 (哈希值)，并以此作为索引。改动文件时，Git 会根据校验和是否变化来判断是否生成新快照。否则只是保留链接指向之前的存储文件。(Git Book 里面关于 Git原理已经介绍的非常详细了，另外[这篇博客](https://lufficc.com/blog/the-core-conception-of-git)总结的比较简洁)\n\n### ２．初次安装与配置：\n\n```\n# 安装 Git\napt-get install git   # install git on ubuntu\n\n# 设置 Git config 变量\ngit config --global user.name \"xxx\"               # 设置 user name 以及 email\ngit config --global user.email xxx@email.com\n\n# 设置文本编辑器\ngit config --global core.editor vim        # git commit提交命令会使用编辑器以记录每次提交的信息\n\n# 查看 Git config 信息\ngit config --list\n```\n### ３．获取仓库 (Repository)：\n使用 Git 对项目或者文件进行版本管理时，需要先配置初始化仓库－－repository 以存储各种项目文件．通常有两种方式:\n\n１. 直接从本地文件夹建立repository  \n```\ngit init    # 将当前目录变成仓库，会在当前文件夹生成　,git文件夹，其中包含了 repository 框架文件\ngit add .　 # 保存快照，并添加文件索引信息至暂存区（索引）\ngit add LICENSE\ngit commit -m \"init project version\"　　    　# 提交更新，生成 commit 对象\n```\n２. Clone 已有 repository 至本地\n```\ngit clone  https://github.com/repository　　　# 拷贝远程仓库所有数据至本地\n```\n### ４．Git 环境基本概念：\n\n&nbsp;　　　　![Git workflow](Pro-Git-1/workflow.png)  \n\n#### 文件状态\nGit 仓库下的文件要么处于已被追踪状态 (tracked)，要么属于未被追踪状态(untracked)，执行 git add，该文件就会被追踪，只有被追踪的文件 (tracked) 才会被纳入版本管理。被追踪的文件通常有几种状态: 已修改(modified)，已暂存(staged)，已提交(committed)：  \n* Modified --- 表示文件已经被修改，但还未保存至仓库数据库。  \n* Staged --- 表示对已改动文件的当前版本做了记录，并进行了保存以便下次提交。   \n* Commited --- 表示文件已经永久的保存在本地仓库。  \n>未被追踪状态文件在 Git 环境下相当于被忽略状态。无论怎么改动文件，Git 并不会保存记录。  \n通过 git rm 可以取消文件的被追踪状态或者直接删除文件，另外也可以利用.gitignore 文件，取消某类特定格式文件或者整个子文件夹内容的追踪。  \n\n#### 仓库区域\n\n根据仓库文件状态，可以引申出三个区域的概念: 工作目录(Working directory / Working Tree)，暂存区(Index / Staging area)，以及仓库目录(Git directory)\n\n* Working directory / Working Tree --- 从Git数据库提取的项目某一个版本的数据。\n>关于工作目录，Git book中文版不太好理解，按英文版的话，应该是指当前项目的某一个版本的内容 (one version of the project)。工作目录下修改完后的文件添加暂存并提交后，就会保存在 Git 数据库。多次提交就会保存多个版本，可以提取任意一个版本的数据至工作目录。直观上可以将 working directory 理解为当前建立本地仓库的文件夹（local repository）。\n\n* Index / Stage --- 索引文件, 用于存储下一次待提交的文件索引信息（文件名，文件校验和等）。\n* Git directory --- 用于存储项目所有元数据以及对象数据库。\n>仓库目录即 整个 .git 文件夹，不过基本上本地修改文件，版本管理结果都存在对象数据库 (.git/objects 文件夹)  \n暂存区就在仓库目录下，暂存区域实际上是一个文件 (.git/objects/index)，存储了暂存文件列表信息(文件名，文件校验和等内容）。每次暂存操作会更新暂存文件的索引信息至该区域。\n\n&nbsp;　 　![](Pro-Git-1/lifecycle.png)\n\n因此，简单来讲，Git 基本工作流程包括:  \n1. 修改操作: 在工作区修改文件　　\n2. 暂存操作: 保存文件快照，并更新文件索引信息至暂存区\n3. 提交操作: 提交版本更新，永久存储至 Git 仓库中的对象数据库  \n\n### ５．Git 核心操作原理：   \n在此之前需要先说明几个基本的概念：\n* Git 对象 --- 主要包括数据对象(blob object), 树对象 (tree object), 以及提交对象 (commit object)。Git 内部就是通 过创建一系列 Git 对象来实现版本的更新和记录。\n>blob object 对象用来存储文件内容；　tree object 用来存储文件名，校验和等信息；　commit object 用来存储提交的内容，包括树对象指针，父提交对象指针，作者信息，提交注释信息。\n数据对象、树对象、提交对象——均以单独文件的形式保存在 .git/objects 目录下。   \n\n* SHA-1 校验和 --- 40 位字符, Git 内部根据对象类型和文件内容进行 SHA-1 校验运算得到的哈希值，作为文件保存地址。  \n* 指针 --- 在 Git 环境下指针就是校验和，SHA-1 哈希值，是 Git 对象保存的地址。  \n>所以通过校验和（指针）就能找到保存的文件对象，文件内容发生变化时，指针也会相应变化。  \n因此在 Git 环境下，可以说一个文件的指针，校验和，哈希值都是同样的意思，都是指文件在 Git 仓库保存的地址。  \nGit 内部文件存储都是通过校验和机制，即先计算文件内容校验和，再以校验和为地址来保存文件\n\nGit 管理版本更新时，核心操作包括暂存操作（Git add）和提交操作 (Git commit)。Git 所做的[实质工作](https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1)——对被追踪的文件生成校验和，将改写的文件内容保存为数据对象 (blob object)，更新暂存区，记录树对象 (tree object)，最后创建提交对象 (commit object)。\n\n#### ５.１ Git add --- 暂存操作\n暂存操作（git add）时, Git 对待暂存的每个文件计算校验和(40个字符的SHA-1 哈希值)，并将文件保存成 blob 对象，最后将文件索引信息（文件名，校验和等）更新至暂存区 (index)。  \n>因此，暂存区包含的文件索引信息实际上是： 每个暂存文件的文件模式(参考 linuc chmod)，文件类型 (blob, tree, 或者 commit)，文件校验和，文件名。  \n文件校验和对应文件在 Git 仓库数据库保存的地址，文件名其实对应的文件在工作目录下的地址，因此，通过索引文件，就可以找到每个文件保存在仓库数据库的 blob 对象，同时，根据文件名恢复 blob 对象至工作目录。\n\n\n此时，可以在 .git/objects 目录下看到生成对应的子文件夹, 每个子文件夹含一个存储文件，表示一个被保存的 blob 数据。对于每个保存的内容, Git生成的 40 位字符校验和, 前 2 位作为文件目录名, 后 38 位作为目录里的文件名。  \n\n通常每个文件被暂存时，.git/objects 都会生成一个对应子文件夹，以及包含在内的 blog 对象。但是如果文件没有被修改，或者两个同类型文件包含相同内容，Git　都只会保存一个相同的 blob 对象。除非其内容发生变化，才会生成新的 blob 对象。\n\n#### ５.２ Git commit --- 提交操作\n在进行提交操作 (git commit) 时，Git 会生成树对象 (tree object)，提交对象（commit object）并对其进行保存。其中， tree object 储存了当前暂存区文件索引信息；　commit object 内部包含了当前树对象指针，上一次提交对象指针，以及提交信息 (git status 内容)，作者信息。（这部分内容是 Gir Pro book [3.1](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B) 以及 [10.2](https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1)章节）。  \n> 树对象其实有点类似 linux 中的目录项，记录了工作区目录下的被暂存文件索引信息。树对象记录的内容跟 index 里的内容相近，但是树对象中的一条内容可以是一个文件的索引信息，也可以是一个文件夹的索引信息，并采用 blob 或者 tree 进行标记区分。所以一个树对象可以包含一个子树对象。  \n顶层树对应工作区根目录项，如果根目录还有子目录，那么就会生成一个子树对象，子树对象包含子目录里的文件索引信息。同时子树对象索引信息被保存在顶层树对象。\n```\n$ git cat-file -p d8bd5ddf4d9ec46bf5c4c1d30f3771143c5c5bfe　　　# tree 对象, 其中　new_filefolder 是子目录\n100644 blob 99d2ea6b6b4b5efa58cc270524193118625921ec\tindex.txt\n040000 tree 9cb543fcd992ed55915adcaef3d77f8001d8dae7\tnew_filefolder\n100644 blob 7fd7b19585f7ffcda9ce662b0e535ac21a2ac6b1\ttest.txt\n```\n\n>准确说法应该是，commit object 包括: 指向顶层树对象的指针, 父提交对象指针, 作者信息，以及提交时的注释信息。  \n\n\n![](Pro-Git-1/tree_commit .png)\n>图片参考　[how git work](https://courses.csail.mit.edu/6.S194/13/lessons/03-git/git-internally.html)\n\n#### ５.３ 底层工作原理\n执行 git add 时，Git 内部通过生成 blob 对象来保存文件内容, 每次对文件修改之后，都会保存一个 blob 对象。在此过程中存在两个问题：　  \n1. 文件每次改动都会保存一个版本，不可能记住所有历史版本对应的文件索引信息;\n2. 每次保存只是文件内容，虽然暂存区临时记录了文件索引信息，但是每次改动都会被更新掉，因此没有真正保存文件名等信息。  \n\n对此，Git 内部采用构建树对象的方式来解决文件索引信息保存的问题，以及将多个文件索引信息组织到一起。   \nGit 根据某一时刻暂存区（index）所表示的状态创建并记录一个对应的树对象. (所以这也是为什么 git commit 之前需要先执行 git add)。\n> git add 操作其实相当于一种缓冲操作，Git 内部也可以直接通过 git commit -a 一次性提交保存所有被追踪内容。但是不如使用 git add 更具灵活性，比如只需要提交部分文件。\n\n具体地，通过 Git 底层命令来研究内部工作原理：\n```\n# 第一次文件改动操作\n$ echo 'version1' > test.txt    # 写入内容至 test.txt\n\n# 第一次暂存操作 step 1 --- 生成 blob 对象\n$ git hash-object -w test.txt   # 将修改后的文件保存成 blob 对象, 该命令返回一个40位字符的哈希值（校验和）\n　　　　　　　　　　　　　　　　　　　　此时会在 .git/objects 目录下生成一个子文件夹，文件夹名为校验和字符的前 2 位,\n　　　　　　　　　　　　　　　　　　　　文件夹下的 blob 对象文件名为校验和后 38 位\n\n5bdcfc19f119febc749eef9a9551bc335cb965e2  # 此时子文件夹名为'5b'，其中的文件名为余下的 38 位字符\n\n# 第一次暂存操作 step 2 ---　更新索引区\n# 这里将第一次改动操作保存的文件校验和（blob 对象地址），文件名，文件模式存至 index\n$ git update-index --add --cacheinfo 10064 5bdcfc19f119febc749eef9a9551bc335cb965e2 test.txt\n\n# 第一次提交操作 step 1 ---　构建树对象\n$ git write-tree                    # 将 index 内容写入 tree 对象, 该命令同样返回40位字符的校验和\nc89f1e026cabe89e7e80a139544a9ae5efc9b470 　　# 同样的，会以校验和命名子文件夹和文件，并保存至.git/objects 目录\n\n$ git cat-file -p c89f1e026cabe89e7e80a139544a9ae5efc9b470       　# 查看该 tree 对象可以发现其中包含了\n100644 blob 5bdcfc19f119febc749eef9a9551bc335cb965e2\ttest.txt　　 文件模式, 类型, 校验和, 文件名信息\n\n# 第一次提交操作 step 2 ---　生成提交对象\n$ echo 'first commit' | git commit-tree c89f1e     # 将树对象以及提交信息写入提交对象\n73fe6c400b3e46adb03b1c035e85d6625cbaba31\n\n$ git cat-file -p 73fe6c400b3e46adb03b1c035e85d6625cbaba31       # 查看 commit　对象, 其中包含\ntree c89f1e026cabe89e7e80a139544a9ae5efc9b470　　　　　　　　　　　　　tree 对象指针，作者信息，提交者信息\nauthor Zakiyi <yishon555@outlook.com> 1555512144 +0800　　　　　    以及提交信息\ncommitter Zakiyi <yishon555@outlook.com> 1555512144 +0800\n\nfirst commit\n```\n```\n# 第二次改动操作\n# 写入新的内容至 test.txt，并添加新文件 index.txt，同时写入内容\n$ echo 'version2' > test.txt    　　　  # 再次修改 test.txt 内容\n$ echo 'version1 index' > index.txt    # 添加新文件 index.txt，并写入内容\n\n# 第二次暂存操作 step 1 --- 生成 blob 对象\n$ git hash-object -w test.txt   　     # 将修改的 test.txt 文件保存成 blob 对象\ndf7af2c382e49245443687973ceb711b2b74cb4a\n\n$ git hash-object -w index.txt　　　    # 将新添加的 index.txt 保存成 blob 对象\n01dde182b1618e0449b63071ac62c5df0adf9358　\n\n# 第二次暂存操作 step 2 --- 更新索引文件\n# 两个改动文件的信息添加至索引区　\n$ git update-index --add --cacheinfo 100644 df7af2c382e49245443687973ceb711b2b74cb4a test.txt\n$ git update-index --add --cacheinfo 100644 01dde182b1618e0449b63071ac62c5df0adf9358 index.txt\n\n# 第二次提交操作 step 1 --- 生成树对象\n$ git write-tree\ne7b27cffc040f6ea742670afc4ae145ef60cbff1\n\n$ git cat-file -p e7b27cffc040f6ea742670afc4ae145ef60cbff1          #　查看新的树对象内容\n100644 blob 01dde182b1618e0449b63071ac62c5df0adf9358\tindex.txt\n100644 blob df7af2c382e49245443687973ceb711b2b74cb4a\ttest.txt\n\n# 第二次提交操作 step 2 --- 生成提交对象\n$ echo 'second commit' | git commit-tree e7b27c -p 73fe6c4　　　　　　# 第二次提交需要指定上次提交对象指针\nf9f76c463ab290ac4aa7dd3eeca7d7e9e1e79f27\n\n$ git cat-file -p f9f76c463ab290ac4aa7dd3eeca7d7e9e1e79f27　　　　　　# 查看第二次提交对象内容\ntree e7b27cffc040f6ea742670afc4ae145ef60cbff1\nparent 73fe6c400b3e46adb03b1c035e85d6625cbaba31\nauthor Zakiyi <yishon555@outlook.com> 1555594132 +0800\ncommitter Zakiyi <yishon555@outlook.com> 1555594132 +0800\n\nsecond commit\n```\n```\n# 第三次改动操作\n# 当前工作区建立子文件夹 new_filefolder, 在其中添加 subtest.txt 并写入内容\n$ mkdir new_filefolder\n$ echo 'version1 subtest' >  new_filefolder/subtest.txt\n\n# 第三次暂存操作 step 1 --- 生成 blob 对象\n$ git hash-object -w new_filefolder/subtest.txt\na0f53bfeaae48f55f3015e4cdafa2561af594b28\n\n# 第三次暂存操作 step 2 --- 更新索引文件\n$ git update-index --add --cacheinfo 100644 a0f53bfeaae48f55f3015e4cdafa2561af594b28\\\n new_filefolder/subtest.txt　　　　　  # 添加()工作目录)子文件夹下文件信息至暂存区时，需要指明子文件夹名\n                                       如果这里不加'new_filefolder', 生成的树对象就不会有子树对象\n\n# 第三次提交操作 step 1 --- 生成树对象\n$ git write-tree　　　　　　　　　　　　　　　　　# 由于添加了子文件夹内容，因此会生成子树对象，.git/objects 下会\n　　　　　　　　　　　　　　　　　　　　　　　　　　　 保存两个文件\nf45d55ce40612653c0a048e354561872307255f3\n\n$ git cat-file -p f45d55ce40612653c0a048e354561872307255f3　　　　　　#　查看新的树对象内容\n100644 blob 01dde182b1618e0449b63071ac62c5df0adf9358\tindex.txt\n040000 tree 9cb543fcd992ed55915adcaef3d77f8001d8dae7\tnew_filefolder   # 新增的子树对象信息\n100644 blob df7af2c382e49245443687973ceb711b2b74cb4a\ttest.txt\n\n# 第三次提交操作 step 2 --- 生成提交对象\n$ echo 'third commit' | git commit-tree f45d55 -p f9f76c4\naa540b90ac49fff6a9d4abe175d4974f5ef7bec2\n\n$ git cat-file -p aa540b90ac49fff6a9d4abe175d4974f5ef7bec2　　　　　　　# 查看第三次提交对象内容\ntree f45d55ce40612653c0a048e354561872307255f3\nparent f9f76c463ab290ac4aa7dd3eeca7d7e9e1e79f27\nauthor Zakiyi <yishon555@outlook.com> 1555597319 +0800\ncommitter Zakiyi <yishon555@outlook.com> 1555597319 +0800\n\nthird commit\n```\n>可以发现每次文件改动 Git 都保存一个新的版本数据，其实是比较浪费空间。 为了解决这一问题，Git 最初向磁盘中存储对象时所使用的格式被称为“松散（loose）”对象格式。 但是，Git 会时不时地将多个这些对象打包成一个称为“包文件（packfile）”的二进制文件，以节省空间和提高效率。 [(10.4章节)](https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E5%8C%85%E6%96%87%E4%BB%B6)\n\n总结就是，暂存操作时，生成 blob 对象，保存文件数据；　提交操作时，生成 tree 对象保存文件索引信息（文件名，校验和等），同时生成 commit 对象（包含当前 tree 对象指针，上一次 commit 对象指针，以及作者信息，提交注释信息）。\n所以，通过当前 commit　对象，根据其中 tree　对象中的文件索引信息就能找到过去每一次提交的文件内容快照（blob 对象），从而实现版本数据的恢复和更新。  \n\n### ６．Git 引用和分支:\n#### ６.１ Git 引用\n每次提交版本修改，Git 都会生成对应的提交对象。当多次提交后，为了方便定位某个提交对象，Git 提出了引用的概念，即建立引用文件 (references，或缩写为 refs) 来保存提交对象校验和，同时以引用文件命名来替代校验和，作为提交对象指针，或者说最为该提交对象别名。\n\n可以在 .git/refs 目录下找到这类含有 SHA-1 值的文件。　gir branch branchname 就是创建一个引用文件，并将最新提交对象校验和内容写进该文件。\n```\n$ find .git/refs\n```\n```\n# 创建引用\n$ echo \"1a410efbd13591db07496601ebc7a059dd55cfe9\" > .git/refs/heads/master\n# 更新引用\n$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9\n```\n除了普通分支引用外，其他特殊引用类型：　HEAD 引用，标签引用，远程引用\n* HEAD 引用 --- 如何知道最新提交对象的校验和（SHA-1 值）呢？ 答案就是 Head 引用，在.git/HEAD 文件中指明了最新提交对象的引用。\n* 标签引用 ---  一个固定的引用，指向给定的 Git 对象, 在 .git/refs/tags 目录下。\n* 远程引用 --- 远程引用是对远程仓库的引用（指针），远程引用是只读的。（.git/refs/remotes 目录下）\n\n#### ６.２ Git 分支:\n\nGit 的分支，其实本质上仅仅是指向提交对象的可变指针(引用)，Git 的默认分支名字是 master，每次提交操作时会自动更新该分支引用。\n>Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符）。在 .git\\refs\\heads 文件夹下,　可以看到默认分支 master 引用文件，其中包含最新一次提交对象的校验和。\n\n当存在远程仓库时，通常做法会在本地设置远程跟踪分支 (Remote-tracking branch) 来指示远程分支的状态，其功能类似与远程分支的书签。被追踪的分支称之为上游分支 (upstream branch)。\n>.git/refs/remotes/origin 文件夹下可以看到 HEAD, mater 等文件，其表示的是远程仓库的 HEAD 引用,　mster　等分支引用。\n\n##### ６.２.１ 分支基本操作：\n* 新建 & 切换  --- 通过 git branch 命令可以新建分支，该分支指向当前最新提交对象。当存在多个分支时，通过 git checkout 命令可以切换指定分支。\n\n* 删除 & 合并 --- git branch -d 以及 git merge 可以实现分支的删除与合并，比如需要修改某个问题时，可以在默认分支 master上 新建一个分支 hotfix，改完提交后，将其部署至线上分支 master 进行合并。\n\n```\n创建分支:\ngit branch testing　　　　　# 该命令创建新分支 testing，指针指向当前最新提交对象\n\n切换分支：\ngit checkout testing\n\n新建以及同时切换分支\n$ git checkout -b testing\n```\n\n```\n$ git checkout master\n\n$ git merge hotfix            # 合并分支\n$ git branch -d hotfix        # 删除 hotfix 分支\n```\n>注意，如果在两个分支中，对同一个文件的同一个部分进行了不同的修改，Git 会出现合并失败，此时需要手动去解决。\n\n![](Pro-Git-1/advance-testing.png)\n\n##### ６.２.２ 远程分支操作:\n远程分支操作主要包括：设置远程跟踪分支，同步，推送\n* 设置远程跟踪分支 --- 将本地仓库分支与本地的远程跟踪分支相关联  \n\n```\n$ git clone 　　　　# Git 会自动将本地　master 分支与远程 master 分支进行关联\n\n# 本地仓库分支已存在，指定其上游跟踪分支  \n$ git branch local_branch -u remote_name/remote_branch     # 指定local branch 的远程跟踪分支\n\n# 本地仓库分支不存在时，创建指定新分支，并指定其上游跟踪分支\n$ git checkout -b local_branch remotename/remote_branch   # 新建本地分支，同时指定远程跟踪分支  \n\n# 或者直接简化\n$ git checkout --track remote_name/remote_branch           # 新建本地分支，命名与其指定远程跟踪分支相同\n```\n\n* 拉取远程分支　---　拉取远程仓库数据至本地，并更新本地仓库数据库\n\n```\ngit fetch remote_name  　# 拉取远程库数据至本地数据库，同时更新本地远程跟踪分支状态，即更新 .git/refs/remotes 引用文件信息\n\ngit pull remote_name   　# 拉取远程数据库数据，并合并分支，注意当存在多个跟踪分支时，需要再次执行 git pull,　以合并本地其他分支\n　　　　　　　　　　　　　　　　与其他对应的上游跟踪分支\n```\n\n* 推送远程分支\n\n```\n#　本地与远程仓库相同分支推送\ngit push origin local_branch　　　　＃　本地仓库分支 local_branch　推送至相同名的远程仓库分支\n\n# 本地仓库与远程仓库不同分支推送\ngit push origin local_branch:remote_branch　　　　# 推送本地仓库指定分支至远程仓库指定分支\n```\n\n总结：\n* 引用是提交对象的指针或者别名，在 .git/refs 文件夹下以文件形式存在，文件内容包含了提交对象的校验和。\n* 分支是可变的引用，可以对其进行删除合并切换等操作，以实现版本数据的修改与管理。\n* 远程跟踪分支是建立在本地仓库的远程分支，用于跟踪记录远程分支状态。\n","tags":["Git"]},{"title":"My New Hexo Blog","url":"/2019/04/14/my-new-hexo-blog/","content":"\n#### 搭建教程：\n\n[macOS环境下利用Github和Hexo部署博客](https://www.jianshu.com/p/1519f22aff24)\n\n[GitHub+Hexo 搭建个人网站详细教程](https://zhuanlan.zhihu.com/p/26625249)\n\n#### Themes:\n\ngithub 源码: [Hexo-Aircloud-Blog](https://github.com/aircloud/hexo-aircloud-blog)\n\npreview 博客：[niexiaotao.cn](http://niexiaotao.cn/)\n\n#### 主要问题：\n\n使用hexo new post时，生成的md文件中默认有date，会造成 hexo generate 无法构建新的静态页面。因此，可能会出现部署新的layout页面出现404 not found，以及新post不显示。解决方法就是更改 scaffolds 中的post模板，删掉里面的 date 就好了．\n\n#### Hexo Blog使用：\n\n[Hexo 常用命令](https://hexo.io/zh-cn/docs/)\n```\nnpm install hexo -g 　　　#安装  \nnpm update hexo -g　　 　#升级  \nhexo init    　　 # 初始化博客，会在当前文件夹建立 'source','themes', '_config.yml'...\nhexo new post \"title\"    # 新建博客文章\n\nhexo clean       # 清除缓存文件 (db.json) 和已生成的静态文件 (public)\nhexo generate    # 生成静态文件, 后面加　-d　直接生成并部署\nhexo deploy      # 部署网站，后面加　-g 部署之前预先生成静态文件\nhexo server      # 启动服务器，-p　重设端口，　-l 启动日记记录\n```\n\n[Markdown语法](https://www.markdownguide.org/basic-syntax)  \n```\n段落: 两个空格　＋　Enter\n强调: *斜体*, **粗体**, ~~删除线~~\n列表: 有序列表使用 * + 空格 + 列表内容; 有序列表使用数字 1. 列表内容\n链接: [text](link)\n图片: ![xx.png](path/xx.jpg)\n\n```\n[换机更新博客方法](https://www.zhihu.com/question/21193762/answer/79109280)  \n\n主要思路还是将本地Hexo原始文件以及生成的网页静态文件分别放在 github 不同的分支，其中 Hexo 分支设为默认分支。换机更新博客时，首先安装好本地 git 环境，[安装](https://linuxize.com/post/how-to-install-node-js-on-ubuntu-18.04/)nodejs, npm, Hexo，再 git clone Hexo repo至本地。本地更新博客时，先更新上传 Hexo 源文件，再生成网页 static 文件并部署至 github pages (另一分支)。\n\n```\n# 将旧机器上博客源文件　git push 至新建的 hexo 分支(github pages repository)\n\n# 新机器上，先 clone 博客源文件至 local\ngit clone git@github.com:xx/xx.github.io.git\n\n# 安装 nodejs, npm, Hexo\nnvm install stable　　　　　　　　# 推荐使用 NVM 安装\nsudo apt-get install npm\nnpm install hexo-cli -g\nnpm install hexo-server --save　　# Hexo 3.0 须先安装 hexo-server 才能使用\n\n# 上传博客修改的博客源文件\ngit add .\ngit commit -m \"update blog\"\ngit push\n\n# 生成静态网页文件，并部署至github pages\nhexo c\nhexo g\nhexo d\n```\n\n\n\n#### 其他比较好看的themes：\n\nNext: [Dandy Xu's Pit](https://dandyxu.me/)（[github](https://github.com/dandyxu/dandyxu.github.io)）\n\nMaupassant: [屠城](https://www.haomwei.com/)（[github](https://github.com/tufu9441/maupassant-hexo)）\n\nTKL: [Kieran's Blog](https://go.kieran.top/)（[github](https://github.com/SuperKieran/TKL)）\n\nAnisina: [Haojen's Blog](http://haojen.github.io/)（[github](https://github.com/Haojen/hexo-theme-Anisina)）\n\nPure: [Cofess](https://blog.cofess.com/)（[github](https://github.com/cofess/hexo-theme-pure)）\n\nPolarBear: [Frost](https://d2fan.com/)（[github](https://github.com/frostfan/hexo-theme-polarbear)）\n\n....\n\n之前一直在用WordPress，不过并不是很喜欢，所以一直在想自己搭一个blog。虽然心心念念，但拖了很久。对于本人这种选择困难症来说，选theme真是一件痛苦的事情。因为比较喜欢偏简洁一点的风格，所以最后选了这个巨简风aircloud。\n","tags":["Hexo"]},{"title":"PHD application","url":"/2019/04/14/PHD-application/","content":"\n#### Monash University 博士申请及签证材料准备\n\n1. Birth Certificate\n\n2. Certificate of Citizenship\n\n3. Passport\n\n4. Invitation letter \n\n   学院官网有EOI form，里面需要说明未来的研究方向和兴趣，这个要跟 prospective supervisor讨论，并导师签字。填好的 form 需要 online application 系统提交。\n\n5. Research Proposal\n\n6. English language transcript (TOEFL)\n\n7. Academic transcripts (with an explanation of the grading schema/s)\n\n8. Bachelor & Master degree\n\n   毕业证，学位证，成绩单都需要英文翻译（涉外公证翻译就好了）\n\n9. Academic curriculum vitae\n\n10. Evidence of award, prize & scholarship\n\n11. Proof of employment or research experience\n\n12. Recommendation letters (one from Monash University)\n\n\u0014\n\n本科学校不提供英文成绩单以及毕业证学位证。由于毕业很久了，目前本科学校官网明确提出不会提供英文翻译版本，需要自己拿中文材料去涉外公证处公证盖章后，学校再跟章。(似乎申请只要NAATI翻译就行，但是后面签证还是需要涉外公证)\n\n研究生学校可以直接打印中英文成绩单以及毕业证学位证。\n\n需要公证的材料：出生证明，护照，成绩单，毕业证，学位证\n\n\n\n[漫谈澳大利亚PhD的申请及其他](http://muchong.com/html/201512/9717824.html)\n\n[澳洲留学公证那些事](https://zhuanlan.zhihu.com/p/27505935)\n\n[南昌大学档案远程服务公告](http://dag.ncu.edu.cn/tzgg/37597.htm)\n\n[澳洲学生签证（Subclass 500）最全申请指南](https://zhuanlan.zhihu.com/p/23656583)\n","tags":["Miscellaneous"]}]